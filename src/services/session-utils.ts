import { ChatSession, ChatHistoryReader } from './readers/types';
import { Logger } from '../utils/logger';

/**
 * Load session content using lazy loading if needed.
 * This is used by both auto-sync and manual import to ensure consistency.
 */
export async function loadSessionContent(
    session: ChatSession,
    reader: ChatHistoryReader,
    workspaceDbPath: string
): Promise<void> {
    if (session.messages.length === 0) {
        Logger.debug(`[SessionUtils] Lazy-loading content for session ${session.id}`);
        const readerWithFetch = reader as any;
        if (readerWithFetch.fetchSessionContent) {
            session.messages = await readerWithFetch.fetchSessionContent(session.id, workspaceDbPath);
            Logger.debug(`[SessionUtils] Loaded ${session.messages.length} messages`);
        }
    }
}

/**
 * Format a chat session as Markdown.
 * This is the unified formatting function used by both auto-sync and manual import.
 */
export function formatSessionMarkdown(session: ChatSession): string {
    const isoDate = new Date(session.timestamp).toISOString().replace('T', ' ').slice(0, 19) + 'Z';

    let header = `<!-- Generated by WayLog -->\n\n`;

    // Include subchannel info if available (for Cline Family)
    const sourceLabel = session.metadata?.subChannel
        ? `${session.metadata.subChannel.toLowerCase()}`
        : session.source.toLowerCase();

    header += `<!-- ${sourceLabel} Session ${session.timestamp} (${isoDate}) -->\n\n`;
    header += `# ${session.title} (${isoDate})\n\n`;

    const body = session.messages.map(msg => {
        const msgDate = msg.timestamp ? new Date(msg.timestamp).toISOString().replace('T', ' ').slice(0, 19) + 'Z' : isoDate;

        let headerText = '';
        if (msg.role === 'user') {
            headerText = `_**User (${msgDate})**_`;
        } else {
            const model = msg.metadata?.model || 'default';
            const mode = msg.metadata?.mode || 'Chat';
            headerText = `_**Assistant (model: ${model}, mode: ${mode})**_`;
        }

        let content = `\n${headerText}\n\n${msg.content}\n`;

        // 1. Add Thinking Blocks (if any)
        if (msg.metadata?.thinking && Array.isArray(msg.metadata.thinking) && msg.metadata.thinking.length > 0) {
            content += `\n<details>\n<summary><b>Thinking Process</b></summary>\n\n${msg.metadata.thinking.join('\n\n')}\n</details>\n`;
        }

        // 2. Add Tool Calls/Results (if any)
        if (msg.metadata?.toolCalls && Array.isArray(msg.metadata.toolCalls)) {
            for (const tool of msg.metadata.toolCalls) {
                const toolName = tool.name || 'unknown_tool';
                const status = tool.status || 'completed';
                const summary = tool.rawArgs ? `Tool use: **${toolName}**` : `Tool result: **${toolName}**`;

                content += `\n<tool-use data-tool-name="${toolName}">\n`;
                content += `<details>\n<summary>${summary} • ${status}</summary>\n\n`;
                if (tool.params) content += `**Parameters:**\n\`\`\`json\n${tool.params}\n\`\`\`\n\n`;
                if (tool.result) {
                    content += `**Result:**\n`;
                    try {
                        const parsed = JSON.parse(tool.result);
                        content += `\`\`\`json\n${JSON.stringify(parsed, null, 2)}\n\`\`\`\n`;
                    } catch (e) {
                        content += `${tool.result}\n`;
                    }
                }
                content += `</details>\n</tool-use>\n`;
            }
        }

        // 3. Add Todos (if any)
        if (msg.metadata?.todos && Array.isArray(msg.metadata.todos) && msg.metadata.todos.length > 0) {
            content += `\n**Plan Progress:**\n`;
            for (const todo of msg.metadata.todos) {
                const icon = todo.status === 'completed' ? '✅' : (todo.status === 'in_progress' ? '⏳' : '⭕');
                content += `- ${icon} ${todo.content || todo}\n`;
            }
        }

        return content + `\n---\n`;
    }).join('\n');

    return header + body;
}

/**
 * Format new messages for incremental append.
 * Used when updating existing files with new messages.
 */
export function formatMessages(messages: ChatSession['messages']): string {
    return messages.map(msg => {
        const msgDate = msg.timestamp ? new Date(msg.timestamp).toISOString().replace('T', ' ').slice(0, 19) + 'Z' : '';
        let headerText = '';

        if (msg.role === 'user') {
            headerText = `_**User (${msgDate})**_`;
        } else {
            const model = msg.metadata?.model || 'default';
            const mode = msg.metadata?.mode || 'Chat';
            headerText = `_**Assistant (model: ${model}, mode: ${mode})**_`;
        }

        let content = `\n${headerText}\n\n${msg.content}\n`;

        // Add metadata (thinking, tools, todos) if present
        if (msg.metadata?.thinking && Array.isArray(msg.metadata.thinking) && msg.metadata.thinking.length > 0) {
            content += `\n<details>\n<summary><b>Thinking Process</b></summary>\n\n${msg.metadata.thinking.join('\n\n')}\n</details>\n`;
        }

        if (msg.metadata?.toolCalls && Array.isArray(msg.metadata.toolCalls)) {
            for (const tool of msg.metadata.toolCalls) {
                const toolName = tool.name || 'unknown_tool';
                const status = tool.status || 'completed';
                const summary = tool.rawArgs ? `Tool use: **${toolName}**` : `Tool result: **${toolName}**`;

                content += `\n<tool-use data-tool-name="${toolName}">\n`;
                content += `<details>\n<summary>${summary} • ${status}</summary>\n\n`;
                if (tool.params) content += `**Parameters:**\n\`\`\`json\n${tool.params}\n\`\`\`\n\n`;
                if (tool.result) {
                    content += `**Result:**\n`;
                    try {
                        const parsed = JSON.parse(tool.result);
                        content += `\`\`\`json\n${JSON.stringify(parsed, null, 2)}\n\`\`\`\n`;
                    } catch (e) {
                        content += `${tool.result}\n`;
                    }
                }
                content += `</details>\n</tool-use>\n`;
            }
        }

        if (msg.metadata?.todos && Array.isArray(msg.metadata.todos) && msg.metadata.todos.length > 0) {
            content += `\n**Plan Progress:**\n`;
            for (const todo of msg.metadata.todos) {
                const icon = todo.status === 'completed' ? '✅' : (todo.status === 'in_progress' ? '⏳' : '⭕');
                content += `- ${icon} ${todo.content || todo}\n`;
            }
        }

        return content + `\n---\n`;
    }).join('\n');
}
